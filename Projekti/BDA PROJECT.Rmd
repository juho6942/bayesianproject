---
title: "BDA PROJECT"
output: html_document
date: "2025-11-19"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# Run chunks?
pre = T
```
## ============================================================
## 0) Packages
## ============================================================
```{r, echo=F}
if (T) {
required_pkgs <- c(
  "tidybayes", "brms", "ggplot2", "metadat",
  "dplyr", "lme4", "posterior",
  "haven", "naniar", "corrplot", "VIM", "R.utils", "tidyr"
)

for (p in required_pkgs) {
  if (!requireNamespace(p, quietly = TRUE)) {
    install.packages(p)
  }
}

lapply(required_pkgs, library, character.only = TRUE)

## Optional: cmdstanr backend for faster sampling (if you later fit models)
if (!requireNamespace("cmdstanr", quietly = TRUE)) {
 install.packages(
  "cmdstanr",
  repos = c("https://mc-stan.org/r-packages/", getOption("repos")),
  type = "source"
)
}
}
```



## ============================================================
## 1) Data import and basic checks
## ============================================================


```{r }
if (pre){
bacteremia = read.csv("data.csv", header=T)

str(bacteremia)
glimpse(bacteremia)
summary(bacteremia)
}
```



## ============================================================
## 2) Basic preprocessing
## ============================================================



```{r}
if (pre){
data <- as.data.frame(bacteremia)



outcome_var <- "bacteremia"
data[[outcome_var]] <- as.factor(data[["BloodCulture"]])

n_patients <- nrow(data)
n_features <- ncol(data) - 1

cat("Patients:", n_patients, "\n")
cat("Features (including outcome):", ncol(data), "\n")

table(data[[outcome_var]])
prop.table(table(data[[outcome_var]]))
}
```



## ============================================================
## 3) Missingness overview
## ============================================================



```{r}
if (pre){
missing_pct <- sapply(data, function(x) mean(is.na(x))) * 100
missing_df <- data.frame(
  variable    = names(missing_pct),
  missing_pct = as.numeric(missing_pct)
)

# Sort by most missing
missing_df <- missing_df[order(-missing_df$missing_pct), ]

# View top/bottom variables by missingness
head(missing_df, 15)   # most missing
tail(missing_df, 15)   # least missing

# Barplot of missingness
ggplot(missing_df, aes(x = reorder(variable, missing_pct), y = missing_pct)) +
  geom_col() +
  coord_flip() +
  labs(
    title = "Percentage of missing values per variable",
    x = "Variable",
    y = "Missing (%)"
  )

# Heatmap of missing vs observed (rows = patients, cols = variables)
vis_miss(data, sort_miss = TRUE) +
  labs(title = "Missingness pattern (sorted by % missing)")
}
```



## ============================================================
## 4) Numeric variables and quick plots
## ============================================================



```{r}
if (pre){
numeric_vars <- names(data)[sapply(data, is.numeric)]

# Choose up to 20 numeric variables with lowest missingness
miss_num    <- missing_pct[numeric_vars]
top_numeric <- head(names(sort(miss_num)), 20)

top_numeric

# Histograms
for (v in top_numeric) {
  print(
    ggplot(data, aes(x = .data[[v]])) +
      geom_histogram(bins = 30) +
      labs(
        title = paste("Distribution of", v),
        x = v,
        y = "Count"
      )
  )
}

# Boxplots by outcome
for (v in top_numeric) {
  print(
    ggplot(data, aes(
      x = .data[[outcome_var]],
      y = .data[[v]],
      fill = .data[[outcome_var]]
    )) +
      geom_boxplot() +
      labs(
        title = paste(v, "by", outcome_var),
        x = outcome_var,
        y = v
      )
  )
}
}
```

## ============================================================
## 5) Correlation structure of numeric variables
## ============================================================
```{r}
if (pre) {
numeric_data <- data %>% dplyr::select(all_of(numeric_vars))

# Correlation matrix using pairwise complete observations
cor_mat <- cor(numeric_data, use = "pairwise.complete.obs")

# Visual correlation matrix
corrplot(
  cor_mat,
  method = "color",
  type   = "upper",
  tl.cex = 0.7,
  tl.col = "black"
)

## Correlation of missingness indicators themselves
miss_ind <- as.data.frame(sapply(data, function(x) as.numeric(is.na(x))))
colnames(miss_ind) <- paste0("miss_", names(data))

miss_cor <- cor(miss_ind)
corrplot(
  miss_cor,
  method = "color",
  type   = "upper",
  tl.cex = 0.5,
  tl.col = "black"
)
}
```



## ============================================================
## 6) Missingness vs outcome (MAR-ish diagnostics)
## ============================================================



```{r}
if (pre){
# Attach outcome to missingness indicators
miss_ind2 <- miss_ind
miss_ind2[[outcome_var]] <- data[[outcome_var]]

# Missing rate by outcome class for each variable
miss_by_outcome <- lapply(names(data), function(var) {
  df <- miss_ind2 %>%
    group_by(.data[[outcome_var]]) %>%
    summarise(
      missing_rate = mean(.data[[paste0("miss_", var)]], na.rm = TRUE),
      .groups      = "drop"
    )
  df$variable <- var
  df
}) %>%
  bind_rows()

# Filter to variables with any missingness
miss_by_outcome_filtered <- miss_by_outcome %>%
  group_by(variable) %>%
  filter(any(missing_rate > 0)) %>%
  ungroup()

# Plot: missing rate by outcome for variables with some missingness
ggplot(
  miss_by_outcome_filtered,
  aes(x = .data[[outcome_var]], y = missing_rate, group = variable)
) +
  geom_col() +
  facet_wrap(~ variable, scales = "free_y") +
  labs(
    title = "Missingness rate by outcome class for each variable",
    x = outcome_var,
    y = "Missing rate"
  )
}
```


## ============================================================
## 7) High / low missingness variables
## ============================================================


```{r}
if(pre) {
high_missing <- missing_df %>% dplyr::filter(missing_pct > 20)
low_missing  <- missing_df %>% dplyr::filter(missing_pct < 10)

high_missing   # candidates to drop or treat carefully
low_missing    # good candidates for initial modelling
}
```



## ============================================================
## 8) Correlation with outcome (numeric) & missingness difference
## ============================================================



```{r}
if (pre){
# Numeric outcome (0/1)
data <- data %>%
  mutate(
    bact_num = ifelse(
      .data[[outcome_var]] == levels(.data[[outcome_var]])[2],
      1, 0
    )
  )

# Numeric features
num_vars <- setdiff(names(data)[sapply(data, is.numeric)], "bact_num")

# Correlation with bacteremia
cor_df <- data.frame(
  variable    = num_vars,
  correlation = sapply(
    num_vars,
    function(v) cor(data[[v]], data$bact_num, use = "pairwise.complete.obs")
  )
) %>%
  arrange(correlation)

ggplot(cor_df, aes(x = reorder(variable, correlation), y = correlation)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  theme_minimal()

# Missingness difference between outcome classes
miss_ind_classes <- as.data.frame(sapply(data, function(x) as.numeric(is.na(x))))
colnames(miss_ind_classes) <- names(data)
miss_ind_classes[[outcome_var]] <- data[[outcome_var]]

out_lv <- levels(data[[outcome_var]])

miss_diff <- miss_ind_classes %>%
  pivot_longer(-all_of(outcome_var), names_to = "variable", values_to = "is_miss") %>%
  group_by(variable, .data[[outcome_var]]) %>%
  summarise(rate = mean(is_miss), .groups = "drop") %>%
  pivot_wider(names_from = .data[[outcome_var]], values_from = rate) %>%
  mutate(diff = .data[[out_lv[2]]] - .data[[out_lv[1]]]) %>%
  arrange(diff)

ggplot(miss_diff, aes(x = reorder(variable, diff), y = diff)) +
  geom_col(fill = "steelblue") +
  coord_flip() +
  theme_minimal()
}


```

## Datan siivous

Tässä ajatuksena puhdistaa datasetti ja kirjoittaa CSV:ksi jonka voi myöhemmin vain lukea sisään. Ainakin täytyy tiputtaa lineaarisesti riippuvia muuttujia (toki ne voisi jotenkin kuvata siten, että riippuvuus poistuu). Sitten täytyy koodata ikäluokat hierarkiaa varten. Lisäksi täytyy tsekata miten NA:iden kanssa toimitaan. vaihtoehtoina ilmeisesti imputoida ennen mallinnusta tai spesifioida miten malli händlää ne. 
```{r}
if (F){
#Tässä tsekkaillaan riippuvuuksia featureiden välillä
df = select(data, -54,-53)  # drop text 
f = bact_num ~ ID  + SEX  + MONOR+ NEUR  + AGE  + MCV  + HGB  + HCT  + PLT  + MCH  + MCHC  + RDW  + MPV  + LYM  + MONO  + EOS  + BASO  + NT  + APTT  + FIB  + SODIUM  + POTASS  + CA  + PHOS  + MG  + CREA  + BUN  + HS  + GBIL  + TP  + ALB  + AMY  + PAMY  + LIP  + CHE  + AP  + ASAT  + ALAT  + GGT  + LDH  + CK  + GLU  + TRIG  + CHOL  + CRP   + EOSR  + LYMR   + NEU    + PDW  + RBC  + WBC 
model = lm(f,df) #here BASOR was dropped from the fit
#summary(model)
library(car)
#alias(model) check multicollinearity
m = car::vif(model)

#Katotaa mitä käy jos filtteröidään pahimmat pois
a= paste(names(m[(m<20)]),collapse=" + ")
a = as.formula(paste("bact_num ~ ", a)) 

newmodel = lm(a,df)
newmodel
summary(newmodel)
car::vif(newmodel)

names(m[(m>10)])

#Punasolujen ihmettelyä 
m2 = lm(bact_num~MCV+MCHC+RBC, df)
car::vif(m2)

m3 = lm(bact_num~ MONO +LYM+ WBC+ BASOR+ MONOR+ NEUR +EOSR, df)
car::vif(m3)


#Olisko NA's silleen että pystyis paikkailemaan valkosoluilla toisiaan 
WBC = c("BASOR", "EOSR", "MONOR", "NEUR", "LYMR", "MONO", "LYM", "NEU", "WBC")
df[WBC][rowSums(is.na(df[WBC]))!=0,]
#ELi mono lym ja wbc on ainakin jos on mitään valkosoluihin liittyvää tietoa.



dropped =subset(data, select= c(NEU, LYMR,MCH, HCT,bacteremia))
newcsv = subset(data, select= -c(NEU, LYMR,MCH, HCT,BloodCulture,bacteremia))
write.csv(newcsv, file="trimmed_data.csv",row.names = F)
write.csv(dropped,file="Excluded_colls.csv", sep=";",row.names = F)



#NA's with mice
install.packages("mice")
library (mice)
imp = mice(newcsv)
long_df = complete(imp, action = "long", include = FALSE)
write.csv(long_df,"NAlessdata.csv",sep=";",row.names = F)



#helper for getting data
getData <- function(x){
  # data with na's
  if (x==1)
    d =read.csv("trimmed_data.csv")
    
  #5 times micied NA-less data
  else if (x==2)
    d = read.csv("NAlessdata.csv")
  

  d
}
}
```
Alla teoriaa VIF:stä. Pienempi parempi, 1 niin täysin riippumaton. 10 on datacampin mukaan tosi iso. Toki fitti tehty n=3k tms. koska r:n stock implementaatio LM:lle handlaa NA:t droppaamalla havainnon.
https://en.wikipedia.org/wiki/Variance_inflation_factor 
https://www.datacamp.com/tutorial/variance-inflation-factor

Keskustelua NA:ista STAN mallinnuksessa:
https://discourse.mc-stan.org/t/how-to-handle-na-values-in-multivariate-models/18800/4
https://cran.r-project.org/web/packages/brms/vignettes/brms_missings.html


## Modeling
Nojoo tossa poolatussa on aika paljon korjattavaa ihan suoralta kädeltä mutta en jaksa tänään enempää 


```{r}
d = getData(1)

d2 = getData(2)  

f = d %>% select(-any_of("bact_num")) %>% names() %>% paste(collapse=" + ") %>% paste("bact_num ~ ",.) %>% as.formula()



#tätä odotellessa kerkesin hakea ärrältä nuuskaa, ~15min
pooled_m = brm(formula = f,
               data=d
               )
pooled_m

```



